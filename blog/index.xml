<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on silenceper blog</title>
    <link>https://silenceper.github.io/blog/</link>
    <description>Recent content in Blog on silenceper blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 20 Nov 2016 02:40:59 +0800</lastBuildDate>
    
	<atom:link href="https://silenceper.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>mysql协议</title>
      <link>https://silenceper.github.io/blog/201611/mysql%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Sun, 20 Nov 2016 02:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201611/mysql%E5%8D%8F%E8%AE%AE/</guid>
      <description>概览：
 mysql授权 执行sql  TODO</description>
    </item>
    
    <item>
      <title>聊聊TCP连接池</title>
      <link>https://silenceper.github.io/blog/201611/%E8%81%8A%E8%81%8Atcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Sun, 20 Nov 2016 02:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201611/%E8%81%8A%E8%81%8Atcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>概览：
 为什么需要连接池 连接失效问题 database/sql 中的连接池 使用连接池管理Thrift链接  以下主要使用Golang作为编程语言
为什么需要连接池 我觉得使用连接池最大的一个好处就是减少连接的创建和关闭，增加系统负载能力， 之前就有遇到一个问题：TCP TIME_WAIT连接数过多导致服务不可用，因为未开启数据库连接池，再加上mysql并发较大，导致需要频繁的创建链接，最终产生了上万的TIME_WAIT的tcp链接，影响了系统性能。
链接池中的的功能主要是管理一堆的链接，包括创建和关闭，所以自己在fatih/pool基础上，改造了一下：https://github.com/silenceper/pool ，使得更加通用一些，增加的一些功能点如下：
 连接对象不单单是net.Conn,变为了interface{}（池中存储自己想要的格式） 增加了链接的最大空闲时间（保证了当连接空闲太久，链接失效的问题）  主要是用到了channel来管理连接，并且能够很好的利用管道的顺序性，当需要使用的时候Get一个连接，使用完毕之后Put放回channel中。
连接失效问题 使用连接池之后就不再是短连接，而是长连接了，就引发了一些问题：
1、长时间空闲，连接断开？ 因为网络环境是复杂的，中间可能因为防火墙等原因，导致长时间空闲的连接会断开，所以可以通过两个方法来解决：
 客户端增加心跳，定时的给服务端发送请求 给连接池中的连接增加最大空闲时间，超时的连接不再使用  在https://github.com/silenceper/pool就增加了一个这样最大空闲时间的参数，在连接创建或者连接被重新返回连接池中时重置，给每个连接都增加了一个连接的创建时间，在取出的时候对时间进行比较：https://github.com/silenceper/pool/blob/master/channel.go#L85
2、当服务端重启之后，连接失效？ 远程服务端很有可能重启，那么之前创建的链接就失效了。客户端在使用的时候就需要判断这些失效的连接并丢弃，在database/sql中就判断了这些失效的连接，使用这种错误表示var ErrBadConn = errors.New(&amp;quot;driver: bad connection&amp;quot;)
另外值得一提的就是在database/sql对这种ErrBadConn错误进行了重试，默认重试次数是两次，所以能够保证即便是链接失效或者断开了，本次的请求能够正常响应（继续往下看就是分析了）。
连接失效的特征
 对连接进行read读操作时，返回EOF错误 对连接进行write操作时，返回write tcp 127.0.0.1:52089-&amp;gt;127.0.0.1:8002: write: broken pipe错误  database/sql 中的连接池 在database/sql中使用连接连接池很简单，主要涉及下面这些配置：
db.SetMaxIdleConns(10) //连接池中最大空闲连接数 db.SetMaxOpenConns(20) //打开的最大连接数 db.SetConnMaxLifetime(300*time.Second)//连接的最大空闲时间(可选)   注：如果MaxIdleConns大于0并且MaxOpenConns小于MaxIdleConns,那么会将MaxIdleConns置为MaxIdleConns
 来看下db这个结构，以及字段相关说明：
type DB struct { //具体的数据库实现的interface{}, //例如https://github.com/go-sql-driver/mysql 就注册并并实现了driver.Open方法，主要是在里面实现了一些鉴权的操作 driver driver.Driver //dsn连接 dsn string //在prepared statement中用到 numClosed uint64 mu sync.</description>
    </item>
    
    <item>
      <title>wechat sdk for golang: 一个简单易用的微信sdk</title>
      <link>https://silenceper.github.io/blog/201609/wechat-sdk-for-golang-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%BE%AE%E4%BF%A1sdk/</link>
      <pubDate>Fri, 16 Sep 2016 15:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201609/wechat-sdk-for-golang-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%BE%AE%E4%BF%A1sdk/</guid>
      <description>一直很想自己用golang写个微信的sdk，目标是简单好用，所以利用闲暇时间（周末，中秋😁），就做出来。
项目地址:https://github.com/silenceper/wechat
目前实现了消息管理，微信网页授权，菜单管理，素材管理几个接口，看下他的基本使用：
以下是一个处理消息接收以及回复的例子：
//配置微信参数 config := &amp;amp;wechat.Config{ AppID: &amp;quot;xxxx&amp;quot;, AppSecret: &amp;quot;xxxx&amp;quot;, Token: &amp;quot;xxxx&amp;quot;, EncodingAESKey: &amp;quot;xxxx&amp;quot;, Cache: memCache } wc := wechat.NewWechat(config) // 传入request和responseWriter server := wc.GetServer(request, responseWriter) server.SetMessageHandler(func(msg message.MixMessage) *message.Reply { //回复消息：演示回复用户发送的消息 text := message.NewText(msg.Content) return &amp;amp;message.Reply{message.MsgText, text} }) server.Serve() server.Send()  </description>
    </item>
    
    <item>
      <title>DCMP: 一个分布式管理配置平台</title>
      <link>https://silenceper.github.io/blog/201608/dcmp-%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E5%B9%B3%E5%8F%B0/</link>
      <pubDate>Tue, 02 Aug 2016 15:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201608/dcmp-%E4%B8%80%E4%B8%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E5%B9%B3%E5%8F%B0/</guid>
      <description>Distributed Configuration Management Platform
提供了一个etcd的管理界面，可通过界面修改配置信息，借助confd可实现配置文件的同步。
GITHUB：https://github.com/silenceper/dcmp
API采用的是Gin Framework，写起api应用来非常方便，前端尝试了一下react。
 传到Github一看，发现css，js的代码比golang还要多 。 😢
 </description>
    </item>
    
    <item>
      <title>Golang 中http包默认路由匹配规则阅读笔记</title>
      <link>https://silenceper.github.io/blog/201605/golang-%E4%B8%ADhttp%E5%8C%85%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 28 May 2016 18:00:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201605/golang-%E4%B8%ADhttp%E5%8C%85%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>一、执行流程 构建一个简单http server：
package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(&amp;quot;hello world&amp;quot;)) }) log.Fatal(http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil)) }  使用http://127.0.0.1:8080/ 就可以看到输出了
通过跟踪http.go包代码，可以发现执行流程基本如下：
1.创建一个Listener监听8080端口 2.进入for循环并Accept请求，没有请求则处于阻塞状态 3.接收到请求，并创建一个conn对象，放入goroutine处理（实现高并发关键） 4.解析请求来源信息获得请求路径等重要信息 5.请求ServerHTTP方法，已经通过上一步获得了ResponseWriter和Request对象 func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) { //此handler即为http.ListenAndServe 中的第二个参数 handler := sh.srv.Handler if handler == nil { //如果handler为空则使用内部的DefaultServeMux 进行处理 handler = DefaultServeMux } if req.RequestURI == &amp;quot;*&amp;quot; &amp;amp;&amp;amp; req.Method == &amp;quot;OPTIONS&amp;quot; { handler = globalOptionsHandler{} } //这里就开始处理http请求 //如果需要使用自定义的mux，就需要实现ServeHTTP方法，即实现Handler接口。 handler.</description>
    </item>
    
    <item>
      <title>你好，世界！</title>
      <link>https://silenceper.github.io/blog/201605/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/</link>
      <pubDate>Sat, 28 May 2016 15:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201605/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C/</guid>
      <description>静下心来，随便写写
Blog被折腾过很多次，从asp的zblog到php的WordPress，一直感觉很炫，自己也自定义过主题。但是感觉脱离了自己建立blog的初衷，仅仅只是想把自己的想法记录下来，所以就直接选用的Hugo+github pages，这样最简单，也更自然。</description>
    </item>
    
    <item>
      <title>tcp time_wait连接数过多导致服务不可用</title>
      <link>https://silenceper.github.io/blog/201601/tcp-time_wait%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8/</link>
      <pubDate>Sun, 03 Jan 2016 15:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201601/tcp-time_wait%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%BF%87%E5%A4%9A%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E4%B8%8D%E5%8F%AF%E7%94%A8/</guid>
      <description>问题出现： 在元旦前夕，自己维护的一个服务突然在高峰时期收到大量报警，赶紧登上服务器看一下：
最开始的反应是memcache tcp read time out ,因为之前也出现过类似的警告所以开始尝试切换memcache，但是运维反馈已经切换了好几台还是不起作用。
又看到有mysql 连接不上报错，怀疑机房内网有问题，然后有开始切换机房加机器，当时问题还是没有得到解决，这下真晕了。。。。 完全排查不出什么问题（因为是高峰时期，tcp连接数自然很高，没有在意是这个问题，自己预估不够）
后来反应过来看到有好几个接口请求数增加，因为发版本的原因，是新版本才会请求这些接口，所以 我暂时屏蔽了这几个口接口问题得到遏制（幸好是用户感知不到的接口）。
排查： 这个问题围绕我好几天，我屏蔽的那几个接口，反复看了好几遍，而且又将其中的sql查询分析，并没有慢请求。。。 这下又彻底懵了，没有头绪。
说来也巧，高峰时期我用netstat -an 命令查看了一些，看到大量tcp time_wait 的连接，赶紧Google了下，tcp time_wait状态是在主动关闭连接的一方保持的一个状态（一般指客户端），
总共的连接数在近3w(ss -s可查)，其中有2w多都是这种连接，而且都是mysql 连接（这里边服务器程序就相当于客户端去连接mysql服务器），到这里心里大致有底了，把数据库连接池加上就好了，Golang提供了两个函数可进行配置：
SetMaxOpenConns用于设置最大打开的连接数，默认值为0表示不限制。 SetMaxIdleConns用于设置闲置的连接数。  为什么会有TIME_WAIT状态？
源于tcp链接关闭中的四次挥手，是主动关闭链接的一方产生的状态： TCP状态转化图三次握手/四次挥手：
四次挥手的过程如下：
 主动关闭连接的一方，调用close()；协议层发送FIN包
 被动关闭的一方收到FIN包后，协议层回复ACK；然后被动关闭的一方，进入CLOSE_WAIT状态，主动关闭的一方等待对方关闭，则进入FIN_WAIT_2状态；此时，主动关闭的一方 等待 被动关闭一方的应用程序，调用close操作
 被动关闭的一方在完成所有数据发送后，调用close()操作；此时，协议层发送FIN包给主动关闭的一方，等待对方的ACK，被动关闭的一方进入LAST_ACK状态；
 主动关闭的一方收到FIN包，协议层回复ACK；此时，主动关闭连接的一方，进入TIME_WAIT状态；而被动关闭的一方，进入CLOSED状态
 等待2MSL时间，主动关闭的一方，结束TIME_WAIT，进入CLOSED状态
  所以time_wait属于tcp正常的一个状态，是为了解决网络的丢包和网络不稳定锁存在的一个状态。
因为当前服务器并发相对较大，所以存在了大量的链接为关闭，如果只是几百的话，也不会影响服务器性能。
使用连接池保存长链接，可使得链接复用，不会出现大量的这种状态。
反思： 问题终于找到解决，但是回过头来想了一下，其实一开始就可以定位到的，只是很多问题集中在一起出现反而让自己不知所措，这个时候如果是敏感的人的话应该马上能够从tcp状态上看出问题，之后线上遇到问题，重要的是先解决（不管通过什么方式），之后再一步步排查。</description>
    </item>
    
  </channel>
</rss>