<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Connection on silenceper blog</title>
    <link>https://silenceper.github.io/tags/connection/</link>
    <description>Recent content in Connection on silenceper blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 20 Nov 2016 02:40:59 +0800</lastBuildDate>
    
	<atom:link href="https://silenceper.github.io/tags/connection/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>聊聊TCP连接池</title>
      <link>https://silenceper.github.io/blog/201611/%E8%81%8A%E8%81%8Atcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</link>
      <pubDate>Sun, 20 Nov 2016 02:40:59 +0800</pubDate>
      
      <guid>https://silenceper.github.io/blog/201611/%E8%81%8A%E8%81%8Atcp%E8%BF%9E%E6%8E%A5%E6%B1%A0/</guid>
      <description>概览：
 为什么需要连接池 连接失效问题 database/sql 中的连接池 使用连接池管理Thrift链接  以下主要使用Golang作为编程语言
为什么需要连接池 我觉得使用连接池最大的一个好处就是减少连接的创建和关闭，增加系统负载能力， 之前就有遇到一个问题：TCP TIME_WAIT连接数过多导致服务不可用，因为未开启数据库连接池，再加上mysql并发较大，导致需要频繁的创建链接，最终产生了上万的TIME_WAIT的tcp链接，影响了系统性能。
链接池中的的功能主要是管理一堆的链接，包括创建和关闭，所以自己在fatih/pool基础上，改造了一下：https://github.com/silenceper/pool ，使得更加通用一些，增加的一些功能点如下：
 连接对象不单单是net.Conn,变为了interface{}（池中存储自己想要的格式） 增加了链接的最大空闲时间（保证了当连接空闲太久，链接失效的问题）  主要是用到了channel来管理连接，并且能够很好的利用管道的顺序性，当需要使用的时候Get一个连接，使用完毕之后Put放回channel中。
连接失效问题 使用连接池之后就不再是短连接，而是长连接了，就引发了一些问题：
1、长时间空闲，连接断开？ 因为网络环境是复杂的，中间可能因为防火墙等原因，导致长时间空闲的连接会断开，所以可以通过两个方法来解决：
 客户端增加心跳，定时的给服务端发送请求 给连接池中的连接增加最大空闲时间，超时的连接不再使用  在https://github.com/silenceper/pool就增加了一个这样最大空闲时间的参数，在连接创建或者连接被重新返回连接池中时重置，给每个连接都增加了一个连接的创建时间，在取出的时候对时间进行比较：https://github.com/silenceper/pool/blob/master/channel.go#L85
2、当服务端重启之后，连接失效？ 远程服务端很有可能重启，那么之前创建的链接就失效了。客户端在使用的时候就需要判断这些失效的连接并丢弃，在database/sql中就判断了这些失效的连接，使用这种错误表示var ErrBadConn = errors.New(&amp;quot;driver: bad connection&amp;quot;)
另外值得一提的就是在database/sql对这种ErrBadConn错误进行了重试，默认重试次数是两次，所以能够保证即便是链接失效或者断开了，本次的请求能够正常响应（继续往下看就是分析了）。
连接失效的特征
 对连接进行read读操作时，返回EOF错误 对连接进行write操作时，返回write tcp 127.0.0.1:52089-&amp;gt;127.0.0.1:8002: write: broken pipe错误  database/sql 中的连接池 在database/sql中使用连接连接池很简单，主要涉及下面这些配置：
db.SetMaxIdleConns(10) //连接池中最大空闲连接数 db.SetMaxOpenConns(20) //打开的最大连接数 db.SetConnMaxLifetime(300*time.Second)//连接的最大空闲时间(可选)   注：如果MaxIdleConns大于0并且MaxOpenConns小于MaxIdleConns,那么会将MaxIdleConns置为MaxIdleConns
 来看下db这个结构，以及字段相关说明：
type DB struct { //具体的数据库实现的interface{}, //例如https://github.com/go-sql-driver/mysql 就注册并并实现了driver.Open方法，主要是在里面实现了一些鉴权的操作 driver driver.Driver //dsn连接 dsn string //在prepared statement中用到 numClosed uint64 mu sync.</description>
    </item>
    
  </channel>
</rss>